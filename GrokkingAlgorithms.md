# Грокаємо алгоритми - Адітья Бхаргава

## Знайомство з алгоритмами

Бінарний пошук використовує відсортований список для пошуку, беручи кожного разу серединій елемент і порівнюючи його з цільовим. Кожна ітерація відсікає половину можливих варіантів. Швидкість O(log N).

Big-O (О-велике) - нотація для представлення відносної швидкості алгоритма (на скільки збільшується час виконання відносно кількості операцій)

## Сортування вибором

Масиви: читання і запис O(1), вставка і видалення O(N). Пов'язані списки: читання і запис O(N), вставка і видалення O(1).

Сортування вибором дозволяє за допомогою двох вкладених циклів проходити список, щоразу вибираючи найменше значення. Найменше значення або переміщується в інший список (поточний зменшується), або ставиться на потрібну позицію поточного (початкова позиція вкладеного цикла зміщується). Реалізація другого варіанту алгоритму:

```py
def selectionSort(arr):
  for i in range(len(arr) - 1):
    min = i
    for j in range(i + 1, len(arr)):
      if arr[j] < arr[min]:
        min = j
    if arr[min] < arr[i]:
      arr[i], arr[min] = arr[min], arr[i]
```

## Рекурсія

Рекурсія - спосіб виразити складну задачу за допомогою спрощених викликів самої себе. Складається з базового випадку, який повертає просту відповідь за відповідної умови, та рекурсивного виклику, який повертає виклик тієї ж функції з простішими даними (прямуючи до базового випадку).

Стек: підтримує додавання і вилучення елементів з одного кінця, вилученим може бути лише останній доданий.

## Швидке сортування

Розділяй і володарюй - рекурсивний підхід до розв'язку складної задачі, за якого замість пошуку відповіді, вона ділиться на базовий випадок та рекурсивний, де шукається розв'язок її спрощеного вигляду.

Для стратегії "розділяй і володарюй" зі списком базовим випадком часто є порожній або одиничний масив.

Алгоритм Евкліда - ефективний метод обчислення найбільшого спільного дільника (НСД). На кожному кроці менше число віднімають від більшого, поки одне не буде дорівнювати нулю. Число, що лишилось - НСД.

Швидке сортування працює відповідно до "розділяй і володарюй", де базовий випадок включає несортуємий масив (довжина менше 2), рекурсивний випадок вибирає опорну точну (н-д перший елемент), ділить інші елементи на два підмасиви з меншими та більшими за опорний і рекурсивно викликається для них, поки не зведе до несортуємих, після чого склеює в порядку менші - опорний - більші.

```py
def quickSort(arr):
  if len(arr) < 2:
    return arr
  pivot = arr[0]
  less = []
  more = []
  for i in arr[1:]:
    if i < pivot:
      less.append(i)
    else:
      more.append(i)
  return quickSort(less) + [pivot] + quickSort(more)
```

## Хеш-таблиці

Хеш-функція отримує на вході рядок, повертає відповідне число (кожному рядку завжди відповідає одне й те саме число, одне число відповідає одному рядку).

Хеш-таблиця: поєднання хеш-функції зі списком. Читання і запис O(1), вставка і видалення O(1). Підходе для моделювання відношень між об'єктами, виявлення дублікатів, кешування.

## Пошук в ширину

Черга: підтримує додавання з одного кінця і вилучення з іншого, вилучиним може бути лише найдавніше доданий.

Граф: складається з вузлів і ребер між ними. Може бути напрямленим та ненапрямленим.

Пошук в ширину - алгоритм обходу графа. Дозволяє визначити наявність шляху між вузлами, якщо він є, то знаходить найкоротший шлях. Використовує чергу і список відвіданих вузлів.

```py
from collections import deque
def check_path(graph, root, target):
  search_queue = deque()
  search_queue += graph[root]
  searched = []
  while search_queue:
    person = search_queue.popleft()
    if not person in searched:
      if (person == target):
        return True
      else:
        search_queue += graph[person]
        searched.append(person)
  return False
```

## Алгоритм Дейкстри