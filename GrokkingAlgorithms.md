# Грокаємо алгоритми - Адітья Бхаргава

## Знайомство з алгоритмами

Бінарний пошук використовує відсортований список для пошуку, беручи кожного разу серединій елемент і порівнюючи його з цільовим. Кожна ітерація відсікає половину можливих варіантів. Швидкість O(log N).

Big-O (О-велике) - нотація для представлення відносної швидкості алгоритма (на скільки збільшується час виконання відносно кількості операцій)

## Сортування вибором

Масиви: читання і запис O(1), вставка і видалення O(N). Пов'язані списки: читання і запис O(N), вставка і видалення O(1).

Сортування вибором дозволяє за допомогою двох вкладених циклів проходити список, щоразу вибираючи найменше значення. Найменше значення або переміщується в інший список (поточний зменшується), або ставиться на потрібну позицію поточного (початкова позиція вкладеного цикла зміщується). Реалізація другого варіанту алгоритму:

```py
def selectionSort(arr):
  for i in range(len(arr) - 1):
    min = i
    for j in range(i + 1, len(arr)):
      if arr[j] < arr[min]:
        min = j
    if arr[min] < arr[i]:
      arr[i], arr[min] = arr[min], arr[i]
```

## Рекурсія

Рекурсія - спосіб виразити складну задачу за допомогою спрощених викликів самої себе. Складається з базового випадку, який повертає просту відповідь за відповідної умови, та рекурсивного виклику, який повертає виклик тієї ж функції з простішими даними (прямуючи до базового випадку).

Стек: підтримує додавання і вилучення елементів з одного кінця, вилученим може бути лише останній доданий.

## Швидке сортування

Розділяй і володарюй - рекурсивний підхід до розв'язку складної задачі, за якого замість пошуку відповіді, вона ділиться на базовий випадок та рекурсивний, де шукається розв'язок її спрощеного вигляду.

Для стратегії "розділяй і володарюй" зі списком базовим випадком часто є порожній або одиничний масив.

Алгоритм Евкліда - ефективний метод обчислення найбільшого спільного дільника (НСД). На кожному кроці менше число віднімають від більшого, поки одне не буде дорівнювати нулю. Число, що лишилось - НСД.

Швидке сортування працює відповідно до "розділяй і володарюй", де базовий випадок включає несортуємий масив (довжина менше 2), рекурсивний випадок вибирає опорну точну (н-д перший елемент), ділить інші елементи на два підмасиви з меншими та більшими за опорний і рекурсивно викликається для них, поки не зведе до несортуємих, після чого склеює в порядку менші - опорний - більші.

```py
def quickSort(arr):
  if len(arr) < 2:
    return arr
  pivot = arr[0]
  less = []
  more = []
  for i in arr[1:]:
    if i < pivot:
      less.append(i)
    else:
      more.append(i)
  return quickSort(less) + [pivot] + quickSort(more)
```

## Хеш-таблиці

Хеш-функція отримує на вході рядок, повертає відповідне число (кожному рядку завжди відповідає одне й те саме число, одне число відповідає одному рядку).

Хеш-таблиця: поєднання хеш-функції зі списком. Читання і запис O(1), вставка і видалення O(1). Підходе для моделювання відношень між об'єктами, виявлення дублікатів, кешування.

## Пошук в ширину

Черга: підтримує додавання з одного кінця і вилучення з іншого, вилучиним може бути лише найдавніше доданий.

Граф: складається з вузлів і ребер між ними. Може бути напрямленим та ненапрямленим.

Пошук в ширину - алгоритм обходу графа. Дозволяє визначити наявність шляху між вузлами, якщо він є, то знаходить найкоротший шлях. Використовує чергу і список відвіданих вузлів.

```py
from collections import deque
def check_path(graph, root, target):
  search_queue = deque()
  search_queue += graph[root]
  searched = []
  while search_queue:
    person = search_queue.popleft()
    if not person in searched:
      if (person == target):
        return True
      else:
        search_queue += graph[person]
        searched.append(person)
  return False
```

## Алгоритм Дейкстри

Алгоритм Дейкстри дозволяє знайти найкоротший шлях між вузлами нарпямленого ациклічного зваженого графа:  
\- знайти вузол з найменшою вартістю (до якого можна дістатись за мінімальну вартість);  
\- перевірити, чи існує більш дешевий шлях для сусідів цього вузла;  
\- повторювати, поки не буде зроблено для всіх вузлів;  
\- вирахувати остаточний шлях (відповідно до остаточних предків).  
Не працює з від'ємними вагами ребер.  
Використовує дві хеш-таблиці, які оновлюються по ходу алгоритма:  
\- сумарна вартість шляху до вузла (сусіди початкового - вартість ребра, інші - безкінечність);  
\- предок вузла (сусіди початкового - початковий, інші - None);  
а також список відвіданих вузлів (за пунктом 1).

## Жадібні алгоритми

NP-повні (NP-complete) задачі мають високу складність рішення (O(2^N), O(!N), всі комбінації, без простого рішення, покриття множини, задача комівояжера).

Жадібні алгоритми дозволяють знайти приблизне рішення за адекватний час. Жадібний алгоритм знаходить оптимальне рішення для кожного етапу окремо, що, як правило, дає близький до оптимального результат в цілому.

Задача найбільш раціонального комбінування вантажу. Жадібний алгоритм полягає в додаванні найбільш габаритних елементів, які вміщаються на поточному етапі.

Задача комівояжера вимагає знайти найкоротший шлях між кількома точками. Жадібний алгоритм її рішення передбачає вибір найкоротшого шляху від поточної точки до залишку інших.

Задача покриття множини вимагає знаходження найменшої кількості підмножин, які покривають всю множину (або найбільшу її частину за обмеженої кількості вибраних підмножин). Жадібний алгоритм її рішення полягає в виборі наступної підмножини з найбільшим покриттям непокритих елементів.


## Динамічне програмування

Динамічне програмування використовується для оптимізації певної характеристики. Працює лише в ситуаціях, коли задача може бути розбита на автономні підзадачі.

В розв'язку з області динамічного програмування будується таблиця. Значення комірки таблиці відповідають оптимізуємій характеристиці. Кожна комірка представляє підзадачу.

Задача комбінування найбільш дорогого вантажу. Будується таблиця, де кожен стовпець `[j]` - значення вантажу, якому кратний вантаж доступних елементів, рядок `[i]` - наступний доступний елемент (в першому доступний лише один елемент, в останньому - всі). Значення комірки `cell[i][j]` вираховується як максимум з попереднього значення `cell[i-1][j]` та суми значення поточного елемента `el[i].value` з попередньою вартістю залишку місця `cell[i-1][j-el[i].weight]`.

Задача визначення найдовшого підрядка. Осями будуть два рядки. Якщо букви підрядків співпадають, значення комірки попереднього рядка і попереднього стовпця (по-діагоналі) +1, інакше 0.

Задача визначення найдовшої спільної послідовності. Осями будуть два рядки. Якщо букви підрядків співпадають, значення комірки попереднього рядка і попереднього стовпця (по-діагоналі) +1, інакше найбільше з попереднього рядка того ж стовпця та того ж рядка попереднього стовпця.

## Алгоритм k найближчих сусідів

Простий і корисний алгоритм для класифікації: Об'єкт відноситься до тої категорії, до якої відноситься найбільше з його k найближчих сусідів.

Побудова рекомендаційної системи: рекомендуються ті елементи, які подобаються k найближчим сусідам.

Ступіньтупеня подібності (близькості) визначається відповідно до теореми Піфагора: `sqrt((a1 - a2)**2 + (b1 - b2)**2 + (c1 - c2)**2 ...)`, де буквою позначена ознака, а цифрою - об'єкт.

Регресія - прогнозування числового значення на основі середнього арифметичного значень k найближчих сусідів.

Для N користувачів варто розглядати sqrt(N) сусідів.