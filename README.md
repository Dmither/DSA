# Структури даних та Алгоритми

## Структури даних

**Структури даних** - сховища, що використовуються для зберігання та організації даних. Спосіб упорядкування даних для ефективного доступу та оновлення.

### Класифікація DS

1. **Лінійні структури даних** - елементи даних розташовані послідовно або лінійно, кожен елемент приєднаний до попереднього і наступного сусідів:

- **статична** СД має фіксований розмір пам'яті (масив);
- **динамічна** СД може оновлювати розмір під час виконання (черга, стек, зв'язний список).

2. **Нелінійні структури даних** - елементи розміщені не послідовно або лінійно, не може бути пройдена за один прогін (дерева, графи).

### Масив

Лінійна статична СД, зберігає дані в нерозривній частині пам'яті. Базується на прив'язці даних до індексів.  
Дозволяє швидко отримувати та оновлювати дані, додавання та видалення повільне за рахунок необхідності зміщення елементів.  
Є базою для реалізації алгоритмів сортування та інших СД, як черга, стек, купа, хеш-таблиця тощо.
Використання в python: `from array import array`, `arr = array("i", [10, 20, 30])`. Підтримує типи `b, h, i, l, q` (int) як char, short, int, long, longlong, `B, H, I, L, Q` (int) як їх беззнакові аналоги, `u` (unicode) як символ юнікода та `f, d` (float) як float та double. Підтримує стандартні маніпуляції з індексами та методи `index(val)`, `append(val)`, `extend(iter)`, `insert(i, val)`, `remove(val)`, `pop(i)`, `count(val)`, `reverse()`. Займає менше місця ніж list, tuple та numpy.array.

### Список

Лінійна динамічна СД, заснована на масивах. Може вміщати різнотипні елементи.  
Використання в Python: `l = [1, 2.2, "a"]`, `l = list((1, 2.2, "a"))`

### Зв'язний список

Лінійна динамічна СД, елементи зберігаютсья в різних частинах пам'яті та зв'язані за допомогою посилань. Має рекурсивну природу. Ділиться на однозв'язний список, двозв'язний список, круговий зв'язний список, подвійний круговий зв'язний список.  
Може легко змінювати розмір за рахунок додавання і видалення елементів зміною посилань, повільно отримує і оновлює за рахунок необхідності проходження до цілі за ланцюгом посилань.  
Слугує базою реалізації інших СД, як черга, стек, граф тощо.  
Використання в Python: `from collections import deque`, `d = deque(iterable)`. Підтримує пошук та зміну за індексом, методи `append(val)`, `appendLeft(val)`, `pop()`, `popLeft()`, `index(val)`, `insert(i, val)`, `remove(val)`, `extend(iter)`, `extendLeft(iter)`, `count(val)`, `reverse()`, `retate(step)`.

### Черга та стек

**Черга** - лінійна СД на базі масиву або зв'язного списку. Введення та отримання можливе лише з одного боку. Останній доданий елемент знімається першим (LIFO).
Черга може бути обмежена в кількості, при переповненні не приймаючи нові або видаляючи старі елементи.
**Стек** - лінійна СД на базі масиву або зв'язного списку. Введення та отримання можливе лише з одного боку. Перший доданий елемент знімається першим (FIFO).
**Двостороння черга** являєтсья середнім між чаргою та стеком, дозволяючи додавання і видалення з обох сторін.  
**черга пріоритетів** має додатковий ключ, що дозволяє попередньо сортувати елементи за пріоритетом. Елементи з однаковим пріорітетом поводяться як в звичайній черзі.  
Використання в Python: _list_, _collections.deque_, _queue.Queue + queue.LifoQueue_.

### Хеш-структури

Структури, де вхідний ключ (незмінного типу) конвертується за допомогою **хеш-функції** в **хеш-індекс**, який займає власне положення в **хеш-таблиці**. Мають лінійну швидкість додавання, пошуку та видалення за рахунок хешування ключів.  
Через те, що кінечній кількості хеш-індексів необхідно зіставити потенційно безкінечну кількість ключів, з'являється небезпека зіткнення (колізії), де присвоєння двом елементам одного ключа унеможливлює зберігання обох. Вирішується або присвоєнню хеш-індексу зв'язного списку значень замість значення або зміщенням значення до вільного індексу (лінійно, квадратично, подвійним хешуванням тощо).  
Розмір хеш-таблиці задається фіксованим і збільшується за необхідності (зазвичай при коефіцієнті елементів до індексів 0,75) для уникненні ускладнення структури через велику кількість колізій.  
Використання в Python: стандартний тип _dict_ або бібіліотека _hashlib_.

### Дерево

Нелінійна СД, розширення зв'язного списку, де кожен елемент може посилатись на масив інших елементів. Ділиться на бінарні (повні бінарні, ідеальні бінарні, бінарні дерева пошуку (BST)), тернарні (тернарні дерева пошуку), n-арні (загальні) дерева.  
Забезпечує помірний доступ/пошук (повільніше масива, швидше зв'язного списка), помірну вставку/видалення (швидше масива, повільніше зв'язного списка).  
Мають декілька алгоритмів обходу: inorder (обходить BST в порядку зростання), preorder (для копії дерева), postorder (для видалення дерева), levelorder, boundary, diagonal.  
Використовуються для ієрархічного структурування даних, алгоритмів стиснення, індексації БД тощо.

### Бінарне дерево

Дерево, кожен вузол якого може мати не більше двох елементів.  
За кількістю дітей: повноцінне (full) (кожен має 2 або 0), вироджене (кожен має 1 або 0), перекошене (вироджене з тільки лівими або правими).  
За заповненістю рівнів: повне (complete) (заповнені всі окрім останнього, останній заповнений зліва), ідеальне (заповнені всі рівні), збалансоване (різниця висот лівого і правого піддерев не більше 1).  
На основі значень вузлів: BST, AVL, Red-Black, B-, B+, Segment.

### Купа

Нелінійна СД, базується на повному бінарному дереві (CBT). Ділиться на мінімальну та максимальну купи, корневий елемент у яких найменший або найбільший відповідно.  
Властивості CBT дозволяють представляти купу у вигляді масива, де при Pi = i, LCi = 2i+1, RCi = 2i+2 (Parent, LeftChild, RightChild index).  
Забезпечує повільне створення на основі несортованого масиву, помірну вставку та видалення, швидке отримання макс/мін значення.  
Використовується для створення пріорітетної черги, біномальної купи, купи Фібоначі, визначення статистики порядку.  
Використання в Python: `import heapq`, `heapq.heapify(li)` - сортує список відповідно до правил мінімальної купи без створення нової СД. Підтримує методи `heappush(li, val)`, `heappop(li)`, `heappushpop(li, val)`, `heapreplace(li, val)`, `nlargest(n, li)`, `nsmallest(n, li)`.

### Граф

Нелінійна СД, розширення дерева, де елементи (вершини) можуть бути пов'язані з будь-якими іншими елементами в будь-якому напрямку. Можуть бути направлені/ненаправлені, зважені/незважені, складні/прості, щільні/розріджені тощо.  
Представляються за допомогою матриць суміжності (швидке додавання, видалення, перевірка, краще для щільних, наочніша) або списків суміжності (ефективне збарігання, швидкий пошук списку суміжних, краще для розріджених).  
Використовується для представлення зв'язків між елементами (соціальних, транспортних, мережевих, взаємодій тощо) та їх аланізу.

### Кістякове дерево

Підмножина графа, ациклічний з'єднаний граф. Застосовується для планування цивільних мереж, комп'ютерної маршрутизації, кластерного аналізу, тощо.  
**Мінімальне кістякове дерево (MST)** - кістякове дерево з найменшою вагою у зваженому графі.

## Алгоритми

**Алгоритм** - скінчення послідовність кроків для вирішення конкретної задачі.

### Асимптоматичні нотації

Математичне позначення відносної ефективності алгоритму (часової або просторової складності). Виражає залежність складності від розміру вхідних даних. Має спрощений вигляд, за якого константи та відносно малі числа ігноруються.  
**Big O notation** - АН, яка виражає найвищу складність алгоритму (верхню межу).  
**Big Theta notation** - АН, яка виражає середню складність алгоритму.  
**Big Omega notation** - АН, яка виражає найнижчу складність алгоритму.

**Розповсюджені асимптотичні позначення:**  
`O(1)` - постійна, не залежить від обсягу (доступ до елементів масива);  
`O(log(n))` - логарифмічна, кожна ітерація відсікає половину значень (бінарний пошук);  
`O(n)` - лінійна, одна ітерація на значення (пошук по-порядку);  
`O(n * log(n))` - поліноміальна, вкладені логарифмічні і лінійні ітерації (перетворення масива в купу);  
`O(n^2)` - квадратична, вкладені лінійні ітерації (бульбашкове сортування);  
`O(2^n)` - експоненціальне; `O(!n)` - факторіальне.

### Алгоритми пошуку

Призначені для перевірки або отримання елемента зі СД, де він зберігається.  
Залежно від типу операції пошуку зазвичай діляться на **послідовний** та **інтервальний** пошук.

**Лінійний пошук** - послідовний АП, починається з одного кінця і проходить кожен елемент до знаходження цілі. Можна використовувати до невідстортованого масиву, для масивів будь-якого типу. Часова складність O(N), повільний для великих наборів. Допоміжний простір O(1), не потребує додаткової пам'яті.  
**Вартовий лінійний пошук** - лінійний пошук з додвананням цілі в кінець масива. Дозволяє виключити перевірку кінця масива що знизить час роботи алгоритма.  
Покращення повторного лінійного пошуку елемента: **транспозиція** - обмін цілі з його попередником; **рух на початок** - обмін цілі з першим елементом; використання хеш-таблиці.  
Швидкість може бути оптимізована створенням декількох потоків та розділенням масиву між ними.

**Двійковий (бінарний) пошук** - інтервальний АП, використовується у відсортованих структурах шляхом ділення інтервалу пошуку навпіл. Часова складність O(log N). Допоміжний простір O(1).  
В python може бути реалізований рекурсивно, циклічно або з модулем bisect.

**Тернарний пошук** - інтервальний АП, використовується в відсортованих структурах шляхом ділення на три рівних частини. Відносно бінарного пошуку може знизити кількість ітерацій шляхом збільшення кількості порівнянь.

**Інтервальний пошук (jump search)** - інтервальний АП, використовується в відсортованих структурах лінійним проходом зі вказаним кроком.

### Алгоритми сортування

Нестабільні алгоритми сортування при однакових ключах можуть змінити їх порядок.

**Сортування вибіркою** - АС, повторний вибір найменшого (найбільшого) з невідсортованої частини списку і переміщення до відсортованої. Часова складність O(N^2). Допоміжний простір O(1). Простий і зрозумілий, підходить невеликим наборам, нестабільний.

**Бульбашкове сортування** - АС, постійно змінює сусідні елементи, якщо їх порядок неправильний. Часова складність O(N^2). Допоміжний простір O(1). Простий і зрозумілий, підходить невеликим наборам, стабільний. Млже бути оптимізований перевіркою доцільності ітерації (переривати, якщо в поточному проході не було переміщень).

**Сортування вставкою** - АС, для кожного нпступного елемента перевіряє, чи більший за попередні. якщо ні, зміщується вліво, поки таким не стане. Часова складність O(N^2). Допоміжний простір O(1). Простий і зрозумілий, підходить невеликим наборам, стабільний. Підходить частково відсортованим наборам.

**Сортування злиттям** - рекурсивний АС, допоки масив має більше одного елемента, ділиться на дві частини, для кожної з яких знову викликається. Таким чином отрумуються два відсортовані підмасиви, з яких беруться менші значення до їх вичерпання. Часова складність O(N logN). Допоміжний простір O(N). Підходить для великих обсягів даних, стабільний, може бути розпаралелений.

**Швидке сортування** - рекурсивний АС, де обирається опорний елемент, двома циклами відбираються менші і більші за нього (обміном в поточному масиві), і для кожної частини рекурсивно викликається (поки частина довша 1) (розділяй і володарюй). Середня часова складність O(N logN), найгірша O(N^2). Допоміжний простір O(N).

**Сортування купою** - АС на основі купи, часова складність O(N logN), може бути трохи повільніший за швидке сортування. Не стабільний.

### Рекурсія

Процес виклику функцією самої себе прямо чи опосередковано. Така функція називається рекурсивною. Ділиться на **пряму** (викликає сама себе: хвостова, головна, деревоподібна, вкладена) та **непряму** (опосередковану) рекурсію. **Хвостова** (рекурсивний виклик вкінці ф-ї) рекурсія може бути оптимізована компілятором (за рахунок відсутності запам'ятовування позиції виклику вона не створює новий виклик, а змінює поточний; складність як у ітерації).

### Кешування

Алгоритми заміни кешу:  
**алгоритм найдавніших використовувань** (least recently used, LRU) видаляє об'єкт, до якого найдавніше звертались, один з найвідоміших, простий, забезпечує гарний коефіцієнт звернення до кешу;  
**алгоритм найменших використовувань** (least frequently used, LFU) видаляє об'єкт, до якого було найменше звернень, має проблему видалення об'єкту, який був сильно актуальний в межах короткого часу;  
**перший прийшов - перший пішов** (FIFO) видаляє найстарший об'єкт, вимагає повторного занесення навіть найактуальніших об'єктів при достатньому розширенні;  
**випадкова заміна** (random replacement, RR) видаляє випадковий об'єкт, не збарігає жодних посилань чи історії, дуже простий в реалізації;  
**алгоритм найновіших використовувань** (most recently used, MRU) видаляє об'єкт із загального списка, який щойно використовувався (передбачається, що до нього вже не треба звертатись, н-д щойно проїхавший автобус).

### Алгоритми обходу дерев

**Пошук в глибину** (depth first search, DFS) має рекурсивний алгоритм обходу дерева, починаючи з корневого вузла повертає його значення та викликається для його піддерев (лівого/правого), має три підвиди відповідно до порядку виклику:  
**inorder traversal** викликається для лівого піддерева, потім повертає значення і викликаєтсья для правого, для бінарних дерев пошуку (BST) відображає прамий (незростаючий) порядок елементів;
**preorder traversal** спочатку повертає значення, потім викликається для піддерев;
**postorder traversal** спочатку викликається для піддерев, потім повертає значення.  

**Пошук в ширину** (порівневий обхід, level order traversal, breadth first search, BFS) обходе дерево в порядку черги, починаючи з кореня та додаючи піддерева в чергу.

**Обхід кордону** (boundary traversal) включає корінь, ліві вузли (крім листкових), листки, праві вузли (крім листків).

**Діагональний обхід** (diagonal traversal) обходить в порядку черги, додаючи в чергу одні піддерева (ліві чи праві) і повертаючи інші.