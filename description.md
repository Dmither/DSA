# Структури даних та Алгоритми

## Структури даних

**Структури даних** - сховища, що використовуються для зберігання та організації даних. Спосіб упорядкування даних для ефективного доступу та оновлення.

### Класифікація DS

1. **Лінійні структури даних** - елементи даних розташовані послідовно або лінійно, кожен елемент приєднаний до попереднього і наступного сусідів:
- **статична** СД має фіксований розмір пам'яті (масив);
- **динамічна** СД може оновлювати розмір під час виконання (черга, стек, зв'язний список).
2. **Нелінійні структури даних** - елементи розміщені не послідовно або лінійно, не може бути пройдена за один прогін (дерева, графи).

### Масив

Лінійна статична СД, зберігає дані в нерозривній частині пам'яті. Базується на прив'язці даних до індексів.  
Дозволяє швидко отримувати та оновлювати дані, додавання та видалення повільне за рахунок необхідності зміщення елементів.  
Є базою для реалізації алгоритмів сортування та інших СД, як черга, стек, купа, хеш-таблиця тощо.

### Список

Лінійна динамічна СД, заснована на масивах. Може вміщати різнотипні елементи.  
Реалізація в Python: `l = [1, 2.2, "a"]`, `l = list((1, 2.2, "a"))`

### Зв'язний список

Лінійна динамічна СД, елементи зберігаютсья в різних частинах пам'яті та зв'язані за допомогою посилань. Має рекурсивну природу. Ділиться на однозв'язний список, двозв'язний список, круговий зв'язний список, подвійний круговий зв'язний список.  
Може легко змінювати розмір за рахунок додавання і видалення елементів зміною посиланю, повільно отримує і оновлює за рахунок необхідності проходження до цілі за ланцюгом посилань.  
Слугує базою реалізації інших СД, як черга, стек, граф тощо.  
Реалізація в Python: `from collections import deque`, `d = deque(iterable)`  
https://realpython.com/linked-lists-python/

### Черга та стек

**Черга** - лінійна СД на базі масиву або зв'язного списку. Введення та отримання можливе лише з одного боку. Останній доданий елемент знімається першим (LIFO).
Черга може бути обмежена в кількості, при переповненні не приймаючи нові або видаляючи старі елементи.
**Стек** - лінійна СД на базі масиву або зв'язного списку. Введення та отримання можливе лише з одного боку. Перший доданий елемент знімається першим (FIFO).
**Двостороння черга** являєтсья середнім між чаргою та стеком, дозволяючи додавання і видалення з обох сторін.  
**черга пріоритетів** має додатковий ключ, що дозволяє попередньо сортувати елементи за пріоритетом. Елементи з однаковим пріорітетом поводяться як в звичайній черзі.  

### Хеш-структури

Структури, де вхідний ключ (незмінного типу) конвертується за допомогою хеш-функції в хеш-індекс, який займає власне положення в хеш-таблиці. Мають лінійну швидкість додавання, пошуку та видалення за рахунок хешування ключів.  
Через те, що кінечній кількості хеш-індексів необхідно зіставити потенційно безкінечну кількість ключів, з'являється небезпека зіткнення (колізії), де присвоєння двом елементам одного ключа унеможливлює зберігання обох. Вирішується або присвоєнню хеш-індексу зв'язного списку значень замість значення або зміщенням значення до вільного індексу (лінійно, квадратично, подвійним хешуванням тощо).  
Розмір хеш-таблиці задається фіксованим і збільшується за необхідності (зазвичай при коофіцієнті елементів до індексів 0,75) для уникненні ускладнення структури через велику кількість колізій.

### Дерево

Нелінійна СД, розширення зв'язного списку, де кожен елемент може посилатись на масив інших елементів. Ділиться на бінарні (повні бінарні, ідеальні бінарні, бінарні дерева пошуку (BST)), тернарні (тернарні дерева пошуку), n-арні (загальні) дерева.  
Забезпечує помірний доступ/пошук (повільніше масива, швидше зв'язного списка), помірну вставку/видалення (швидше масива, повільніше зв'язного списка).  
Мають декілька алгоритмів обходу: inorder (обходить BST в порядку зростання), preorder (для копії дерева), postorder (для видалення дерева), levelorder, boundary, diagonal.  
Використовуються для ієрархічного структурування даних, алгоритмів стиснення, індексації БД тощо.  

### Бінарне дерево

Дерево, кожен вузол якого може мати не більше двох елементів.  
За кількістю дітей: повноцінне (full) (кожен має 2 або 0), вироджене (кожен має 1 або 0), перекошене (вироджене з тільки лівими або правими).  
За заповненістю рівнів: повне (complete) (заповнені всі окрім останнього, останній заповнений зліва), ідеальне (заповнені всі рівні), збалансоване (різниця висот лівого і правого піддерев не більше 1).  
На основі значень вузлів: BST, AVL, Red-Black, B-, B+, Segment.

### Купа

Нелінійна СД, базується на повному бінарному дереві (CBT). Ділиться на мінімальну та максимальну купи, корневий елемент у яких найменший або найбільший відповідно.  
Властивості CBT дозволяють представляти купу у вигляді масива, де при Pi = i, LCi = 2i+1, RCi = 2i+2 (Parent, LeftChild, RightChild index).  
Забезпечує повільне створення на основі несортованого масиву, помірну вставку та видалення, швидке отримання макс/мін значення.  
Використовується для створення пріорітетної черги, біномальної купи, купи Фібоначі, визначення статистики порядку.

### Граф

Нелінійна СД, розширення дерева, де елементи (вершини) можуть бути пов'язані з будь-якими іншими елементами в будь-якому напрямку. Можуть бути направлені/ненаправлені, зважені/незважені, складні/прості, щільні/розріджені тощо.  
Представляються за допомогою матриць суміжності (швидке додавання, видалення, перевірка, краще для щільних, наочніша) або списків суміжності (ефективне збарігання, швидкий пошук списку суміжних, краще для розріджених).  
Використовується для представлення зв'язків між елементами (соціальних, транспортних, мережевих, взаємодій тощо) та їх аланізу.  

### Кістякове дерево

Підмножина графа, ациклічний з'єднаний граф. Застосовується для планування цивільних мереж, комп'ютерної маршрутизації, кластерного аналізу, тощо.  
**Мінімальне кістякове дерево (MST)** - кістякове дерево з найменшою вагою у зваженому графі.

## Алгоритми

**Алгоритм** - скінчення послідовність кроків для вирішення конкретної задачі.

### Асимптоматичні нотації

**Асимптотичні нотації** - математичне позначення відносної ефективності алгоритму (часової або просторової складності). Виражає залежність складності від розміру вхідних даних. Має спрощений вигляд, за якого константи та відносно малі числа ігноруються.  
**Big O notation** - АН, яка виражає найвищу складність алгоритму (верхню межу).  
**Big Theta notation** - АН, яка виражає середню складність алгоритму.  
**Big Omega notation** - АН, яка виражає найнижчу складність алгоритму.

**Розповсюджені асимптотичні позначення:**  
`O(1)` - постійна, не залежить від обсягу (доступ до елементів масива);  
`O(log(n))` - логарифмічна, кожна ітерація відсікає половину значень (бінарний пошук);  
`O(n)` - лінійна, одна ітерація на значення (пошук по-порядку);  
`O(n * log(n))` - квазілінійна, вкладені логарифмічні і лінійні ітерації (сортування злиттям);  
`O(n^2)` - квадратична, вкладені лінійні ітерації (бульбашкове сортування);  
`O(2^n)` - експоненціальне; `O(!n)` - факторіальне.


## Завдання

!!! Створити хеш-таблицю за допомогою тест-керованої розробки: https://realpython.com/python-hash-table/#build-a-hash-table-prototype-in-python-with-tdd